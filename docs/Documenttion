# OpenTelemetry Metrics Implementation in Go
## A Comprehensive Shopping Cart Service with Observability

### Table of Contents
1. [Introduction](#introduction)
2. [Architecture Overview](#architecture-overview)
3. [Prerequisites and Dependencies](#prerequisites-and-dependencies)
4. [Implementation Details](#implementation-details)
5. [Metrics Types Implementation](#metrics-types-implementation)
6. [API Endpoints](#api-endpoints)
7. [Deployment and Configuration](#deployment-and-configuration)
8. [Testing and Validation](#testing-and-validation)
9. [Performance Considerations](#performance-considerations)
10. [Troubleshooting](#troubleshooting)

---

## 1. Introduction

This document provides a comprehensive guide to implementing OpenTelemetry metrics in a Go-based shopping cart service. The implementation demonstrates the three core metric types - Counter, Histogram, and Gauge - while showcasing industry best practices for observability in microservices architecture.

### 1.1 Project Objectives

The primary objectives of this implementation are:

- **Demonstrate OpenTelemetry Integration**: Showcase proper integration of OpenTelemetry metrics SDK in a production-ready Go application
- **Implement All Metric Types**: Provide working examples of Counter, Histogram, and Gauge metrics
- **Real-world Use Case**: Build a realistic shopping cart service that generates meaningful telemetry data
- **Industry Standards Compliance**: Follow OpenTelemetry specifications and Go best practices
- **Documentation Excellence**: Provide comprehensive documentation suitable for production deployment

### 1.2 Business Context

The shopping cart service represents a common microservice pattern found in e-commerce platforms. By instrumenting this service with OpenTelemetry metrics, we can:

- Track service health and performance
- Monitor business metrics (cart items, active users)
- Identify and troubleshoot performance bottlenecks
- Enable data-driven decision making through observability

---

## 2. Architecture Overview

### 2.1 System Components

The application consists of several key components working together to provide a fully instrumented shopping cart service:

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   HTTP Client   │────│  MetricsServer   │────│   CartService   │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                                │                        │
                                │                        │
                       ┌────────▼────────┐      ┌────────▼────────┐
                       │  Metrics        │      │  In-Memory      │
                       │  Middleware     │      │  Cart Storage   │
                       └─────────────────┘      └─────────────────┘
                                │
                                │
                       ┌────────▼────────┐
                       │  OpenTelemetry  │
                       │  Metrics SDK    │
                       └─────────────────┘
                                │
                                │
                       ┌────────▼────────┐
                       │   Prometheus    │
                       │    Exporter     │
                       └─────────────────┘
```

### 2.2 Data Flow

1. **HTTP Request Reception**: The MetricsServer receives HTTP requests through various endpoints
2. **Middleware Processing**: Each request passes through metrics middleware that captures timing and metadata
3. **Business Logic Execution**: The CartService processes the business logic (add/remove/get cart items)
4. **Metrics Collection**: OpenTelemetry SDK collects metrics during request processing
5. **Metrics Export**: Prometheus exporter makes metrics available for scraping
6. **Observable Gauge Updates**: Background callbacks update gauge metrics periodically

### 2.3 Concurrency Model

The application uses Go's built-in concurrency features:

- **Goroutine-safe Operations**: All cart operations are protected by mutexes
- **Read-Write Locks**: Efficient concurrent access patterns for cart data
- **Context Propagation**: Proper context handling for request tracing and cancellation
- **Background Metrics Collection**: Separate goroutines handle periodic gauge metric updates

---

## 3. Prerequisites and Dependencies

### 3.1 Go Version Requirements

- **Minimum Go Version**: 1.19+
- **Recommended Go Version**: 1.21+ for optimal performance and feature support

### 3.2 Required Dependencies

Add the following dependencies to your `go.mod` file:

```go
module shopping-cart-service

go 1.21

require (
    go.opentelemetry.io/otel v1.21.0
    go.opentelemetry.io/otel/exporters/prometheus v0.44.0
    go.opentelemetry.io/otel/metric v1.21.0
    go.opentelemetry.io/otel/sdk v1.21.0
    go.opentelemetry.io/otel/sdk/metric v1.21.0
    go.opentelemetry.io/otel/semconv/v1.17.0 v1.17.0
)

require (
    github.com/beorn7/perks v1.0.1 // indirect
    github.com/cespare/xxhash/v2 v2.2.0 // indirect
    github.com/go-logr/logr v1.3.0 // indirect
    github.com/go-logr/stdr v1.2.2 // indirect
    github.com/golang/protobuf v1.5.3 // indirect
    github.com/matttproud/golang_protobuf_extensions v1.0.4 // indirect
    github.com/prometheus/client_golang v1.17.0 // indirect
    github.com/prometheus/client_model v0.5.0 // indirect
    github.com/prometheus/common v0.45.0 // indirect
    github.com/prometheus/procfs v0.12.0 // indirect
    golang.org/x/sys v0.13.0 // indirect
    google.golang.org/protobuf v1.31.0 // indirect
)
```

### 3.3 Installation Commands

```bash
# Initialize Go module
go mod init shopping-cart-service

# Add OpenTelemetry dependencies
go get go.opentelemetry.io/otel@latest
go get go.opentelemetry.io/otel/exporters/prometheus@latest
go get go.opentelemetry.io/otel/metric@latest
go get go.opentelemetry.io/otel/sdk@latest
go get go.opentelemetry.io/otel/sdk/metric@latest
go get go.opentelemetry.io/otel/semconv/v1.17.0@latest

# Tidy up dependencies
go mod tidy
```

---

## 4. Implementation Details

### 4.1 Core Data Structures

#### CartItem Structure
```go
type CartItem struct {
    ID       string  `json:"id"`       // Unique item identifier
    Name     string  `json:"name"`     // Human-readable item name
    Price    float64 `json:"price"`    // Item price in currency units
    Quantity int     `json:"quantity"` // Number of items
}
```

#### Cart Structure
```go
type Cart struct {
    UserID string     `json:"user_id"` // User identifier
    Items  []CartItem `json:"items"`   // Collection of cart items
    mutex  sync.RWMutex                // Concurrent access protection
}
```

### 4.2 Service Architecture

#### CartService Structure
The `CartService` serves as the central business logic component, managing cart operations while collecting comprehensive metrics:

```go
type CartService struct {
    carts map[string]*Cart // In-memory cart storage
    mutex sync.RWMutex     // Concurrent access protection

    // OpenTelemetry Metrics
    errorCounter    metric.Int64Counter         // Error tracking
    requestLatency  metric.Float64Histogram     // Latency measurement
    cartItemsGauge  metric.Int64ObservableGauge // Cart items count
    requestCounter  metric.Int64Counter         // Total requests
    activeUsers     metric.Int64ObservableGauge // Active users count
}
```

### 4.3 Metrics Initialization

The service initializes OpenTelemetry components during startup:

1. **Resource Creation**: Defines service metadata and attributes
2. **Exporter Configuration**: Sets up Prometheus exporter for metrics exposure
3. **Meter Provider Setup**: Configures the global meter provider
4. **Metric Instruments Creation**: Initializes all metric types
5. **Callback Registration**: Registers observable gauge callbacks

#### Resource Configuration
```go
res, err := resource.Merge(
    resource.Default(),
    resource.NewWithAttributes(
        semconv.SchemaURL,
        semconv.ServiceName("shopping-cart-service"),
        semconv.ServiceVersion("1.0.0"),
        semconv.ServiceInstanceID("instance-1"),
        attribute.String("environment", "development"),
    ),
)
```

### 4.4 HTTP Server Implementation

#### MetricsServer Structure
```go
type MetricsServer struct {
    service *CartService // Business logic service
    server  *http.Server // HTTP server instance
}
```

The server provides RESTful endpoints with automatic metrics collection through middleware.

---

## 5. Metrics Types Implementation

### 5.1 Counter Metrics

Counters track monotonically increasing values, perfect for counting events like requests and errors.

#### Error Counter Implementation
```go
service.errorCounter, err = meter.Int64Counter(
    "http_requests_errors_total",
    metric.WithDescription("Total number of HTTP error requests"),
    metric.WithUnit("1"),
)
```

**Usage Pattern**:
```go
func (cs *CartService) recordError(ctx context.Context, errorType, endpoint string, statusCode int) {
    cs.errorCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("error_type", errorType),
            attribute.String("endpoint", endpoint),
            attribute.Int("status_code", statusCode),
        ),
    )
}
```

**Key Features**:
- **Monotonic Increment**: Values only increase over time
- **Rich Attributes**: Track error types, endpoints, and status codes
- **Aggregatable**: Can be summed across instances and time windows

#### Request Counter Implementation
```go
service.requestCounter, err = meter.Int64Counter(
    "http_requests_total",
    metric.WithDescription("Total number of HTTP requests"),
    metric.WithUnit("1"),
)
```

### 5.2 Histogram Metrics

Histograms measure distributions of values, ideal for latency and size measurements.

#### Request Latency Histogram
```go
service.requestLatency, err = meter.Float64Histogram(
    "http_request_duration_seconds",
    metric.WithDescription("HTTP request latency in seconds"),
    metric.WithUnit("s"),
    metric.WithExplicitBucketBoundaries(0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0),
)
```

**Bucket Configuration**:
- **Sub-millisecond**: 0.001s - Captures very fast operations
- **Millisecond Range**: 0.005s, 0.01s, 0.025s, 0.05s - Common web response times
- **Fast Responses**: 0.1s, 0.25s, 0.5s - Acceptable user experience
- **Slow Responses**: 1.0s, 2.5s, 5.0s, 10.0s - Performance issues detection

**Usage Pattern**:
```go
func (cs *CartService) recordLatency(ctx context.Context, duration time.Duration, method, endpoint string, statusCode int) {
    cs.requestLatency.Record(ctx, duration.Seconds(),
        metric.WithAttributes(
            attribute.String("method", method),
            attribute.String("endpoint", endpoint),
            attribute.Int("status_code", statusCode),
        ),
    )
}
```

**Statistical Capabilities**:
- **Percentiles**: Calculate P50, P95, P99 response times
- **Rate Calculations**: Requests per second analysis
- **SLA Monitoring**: Track compliance with response time targets

### 5.3 Gauge Metrics

Gauges represent values that can increase or decrease, perfect for measuring current state.

#### Cart Items Gauge Implementation
```go
service.cartItemsGauge, err = meter.Int64ObservableGauge(
    "cart_items_total",
    metric.WithDescription("Total number of items in user carts"),
    metric.WithUnit("1"),
)
```

#### Active Users Gauge Implementation
```go
service.activeUsers, err = meter.Int64ObservableGauge(
    "active_users_total",
    metric.WithDescription("Total number of active users with carts"),
    metric.WithUnit("1"),
)
```

**Observable Callback Function**:
```go
func (cs *CartService) observeCartMetrics(ctx context.Context, observer metric.Observer) error {
    cs.mutex.RLock()
    defer cs.mutex.RUnlock()

    // Count total items across all carts
    totalItems := int64(0)
    for _, cart := range cs.carts {
        cart.mutex.RLock()
        for _, item := range cart.Items {
            totalItems += int64(item.Quantity)
        }
        cart.mutex.RUnlock()
    }

    // Observe metrics
    observer.ObserveInt64(cs.cartItemsGauge, totalItems)
    observer.ObserveInt64(cs.activeUsers, int64(len(cs.carts)))

    return nil
}
```

**Key Characteristics**:
- **Current State**: Represents present values, not cumulative
- **Bidirectional**: Can increase or decrease over time
- **Observable Pattern**: Automatically collected via callbacks
- **Business Metrics**: Tracks meaningful business indicators

---

## 6. API Endpoints

### 6.1 Cart Management Endpoints

#### Add Item to Cart
**Endpoint**: `POST /cart/add`

**Request Body**:
```json
{
    "user_id": "user123",
    "item": {
        "id": "item456",
        "name": "Premium Widget",
        "price": 29.99,
        "quantity": 2
    }
}
```

**Response**:
```json
{
    "status": "success"
}
```

**Metrics Generated**:
- Request counter increment
- Latency histogram record
- Error counter (if applicable)
- Cart items gauge update (via callback)

#### Get Cart Contents
**Endpoint**: `GET /cart/get?user_id=user123`

**Response**:
```json
{
    "user_id": "user123",
    "items": [
        {
            "id": "item456",
            "name": "Premium Widget",
            "price": 29.99,
            "quantity": 2
        }
    ]
}
```

#### Remove Item from Cart
**Endpoint**: `DELETE /cart/remove`

**Request Body**:
```json
{
    "user_id": "user123",
    "item_id": "item456"
}
```

### 6.2 Operational Endpoints

#### Health Check
**Endpoint**: `GET /health`

**Response**:
```json
{
    "status": "healthy",
    "timestamp": "2024-01-15T10:30:00Z",
    "service": "shopping-cart-service"
}
```

#### Error Simulation
**Endpoint**: `GET /simulate-error`

Randomly returns HTTP error codes (400, 401, 403, 404, 500, 502, 503) to test error metrics collection.

#### Metrics Exposure
**Endpoint**: `GET /metrics`

Exposes Prometheus-formatted metrics for scraping:
```
# HELP http_requests_total Total number of HTTP requests
# TYPE http_requests_total counter
http_requests_total{endpoint="/cart/add",method="POST",status_code="200"} 150

# HELP http_request_duration_seconds HTTP request latency in seconds
# TYPE http_request_duration_seconds histogram
http_request_duration_seconds_bucket{endpoint="/cart/add",method="POST",status_code="200",le="0.001"} 0
http_request_duration_seconds_bucket{endpoint="/cart/add",method="POST",status_code="200",le="0.005"} 12
```

---

## 7. Deployment and Configuration

### 7.1 Local Development Setup

#### Building the Application
```bash
# Clone or create the project directory
mkdir shopping-cart-service
cd shopping-cart-service

# Initialize Go module
go mod init shopping-cart-service

# Create main.go with the provided code
# Add dependencies
go mod tidy

# Build the application
go build -o cart-service main.go
```

#### Running the Service
```bash
# Run directly with Go
go run main.go

# Or run the compiled binary
./cart-service
```

**Expected Output**:
```
2024/01/15 10:30:00 Starting server on :8080
2024/01/15 10:30:00 Metrics available at http://localhost:8080/metrics
2024/01/15 10:30:00 Health check at http://localhost:8080/health
```

### 7.2 Docker Deployment

#### Dockerfile
```dockerfile
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY main.go ./
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o cart-service main.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/

COPY --from=builder /app/cart-service .

EXPOSE 8080

CMD ["./cart-service"]
```

#### Building and Running with Docker
```bash
# Build Docker image
docker build -t shopping-cart-service .

# Run container
docker run -p 8080:8080 shopping-cart-service
```

### 7.3 Kubernetes Deployment

#### Deployment Manifest
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: shopping-cart-service
  labels:
    app: shopping-cart-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: shopping-cart-service
  template:
    metadata:
      labels:
        app: shopping-cart-service
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: shopping-cart-service
        image: shopping-cart-service:latest
        ports:
        - containerPort: 8080
        env:
        - name: OTEL_SERVICE_NAME
          value: "shopping-cart-service"
        - name: OTEL_SERVICE_VERSION
          value: "1.0.0"
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: shopping-cart-service
spec:
  selector:
    app: shopping-cart-service
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: ClusterIP
```

### 7.4 Environment Configuration

#### Environment Variables
- `OTEL_SERVICE_NAME`: Override service name (default: "shopping-cart-service")
- `OTEL_SERVICE_VERSION`: Override service version (default: "1.0.0")
- `OTEL_SERVICE_INSTANCE_ID`: Override instance ID (default: "instance-1")
- `PORT`: Override HTTP port (default: "8080")

#### Configuration in Code
```go
serviceName := os.Getenv("OTEL_SERVICE_NAME")
if serviceName == "" {
    serviceName = "shopping-cart-service"
}

serviceVersion := os.Getenv("OTEL_SERVICE_VERSION")
if serviceVersion == "" {
    serviceVersion = "1.0.0"
}
```

---

## 8. Testing and Validation

### 8.1 Functional Testing

#### Manual API Testing with curl

**Add items to cart**:
```bash
curl -X POST http://localhost:8080/cart/add \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": "test_user",
    "item": {
      "id": "widget_123",
      "name": "Test Widget",
      "price": 19.99,
      "quantity": 2
    }
  }'
```

**Retrieve cart contents**:
```bash
curl "http://localhost:8080/cart/get?user_id=test_user"
```

**Remove item from cart**:
```bash
curl -X DELETE http://localhost:8080/cart/remove \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": "test_user",
    "item_id": "widget_123"
  }'
```

#### Automated Testing Script
```bash
#!/bin/bash
# test_service.sh

BASE_URL="http://localhost:8080"

echo "Testing Shopping Cart Service..."

# Test health endpoint
echo "1. Health Check"
curl -s "$BASE_URL/health" | jq .

# Add item to cart
echo "2. Adding item to cart"
curl -s -X POST "$BASE_URL/cart/add" \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": "test_user",
    "item": {"id": "item1", "name": "Widget", "price": 10.0, "quantity": 1}
  }' | jq .

# Get cart
echo "3. Getting cart contents"
curl -s "$BASE_URL/cart/get?user_id=test_user" | jq .

# Check metrics
echo "4. Checking metrics"
curl -s "$BASE_URL/metrics" | grep -E "(http_requests_total|cart_items_total)"

echo "Testing completed!"
```

### 8.2 Metrics Validation

#### Verifying Counter Metrics
```bash
# Check total requests
curl -s http://localhost:8080/metrics | grep "http_requests_total"

# Expected output:
# http_requests_total{endpoint="/cart/add",method="POST",status_code="200"} 5
# http_requests_total{endpoint="/health",method="GET",status_code="200"} 10
```

#### Verifying Histogram Metrics
```bash
# Check request latency distribution
curl -s http://localhost:8080/metrics | grep "http_request_duration_seconds"

# Expected output includes buckets and statistics:
# http_request_duration_seconds_bucket{endpoint="/cart/add",method="POST",status_code="200",le="0.005"} 2
# http_request_duration_seconds_sum{endpoint="/cart/add",method="POST",status_code="200"} 0.123
# http_request_duration_seconds_count{endpoint="/cart/add",method="POST",status_code="200"} 5
```

#### Verifying Gauge Metrics
```bash
# Check current cart state
curl -s http://localhost:8080/metrics | grep -E "(cart_items_total|active_users_total)"

# Expected output:
# cart_items_total 15
# active_users_total 3
```

### 8.3 Load Testing

#### Using Apache Bench (ab)
```bash
# Test add cart endpoint
ab -n 1000 -c 10 -p cart_payload.json -T application/json \
   http://localhost:8080/cart/add

# Test get cart endpoint
ab -n 1000 -c 10 \
   "http://localhost:8080/cart/get?user_id=load_test_user"
```

#### Payload file (cart_payload.json)
```json
{
  "user_id": "load_test_user",
  "item": {
    "id": "load_test_item",
    "name": "Load Test Widget",
    "price": 25.99,
    "quantity": 1
  }
}
```

#### Using wrk for Advanced Load Testing
```bash
# Install wrk
# Ubuntu/Debian: sudo apt-get install wrk
# macOS: brew install wrk

# Basic load test
wrk -t4 -c100 -d30s --latency http://localhost:8080/health

# POST request load test
wrk -t4 -c100 -d30s -s post_script.lua http://localhost:8080/cart/add
```

**post_script.lua**:
```lua
wrk.method = "POST"
wrk.body = '{"user_id":"wrk_user","item":{"id":"wrk_item","name":"WRK Item","price":15.0,"quantity":1}}'
wrk.headers["Content-Type"] = "application/json"
```

---

## 9. Performance Considerations

### 9.1 Memory Management

#### Cart Storage Optimization
The current implementation uses in-memory storage with the following characteristics:

**Memory Usage Estimation**:
- Each CartItem: ~100 bytes (depending on string lengths)
- Each Cart: ~200 bytes + (number of items × 100 bytes)
- 1000 active users with 5 items each: ~700KB

**Optimization Strategies**:
1. **Item Pooling**: Reuse CartItem objects to reduce GC pressure
2. **Periodic Cleanup**: Remove inactive carts after timeout
3. **Memory Limits**: Implement maximum cart limits per user

#### Implementation Example
```go
type CartService struct {
    // ... existing fields ...
    maxCartsPerUser int
    cartTimeout     time.Duration
    lastAccess      map[string]time.Time
}

func (cs *CartService) cleanupInactiveCarts() {
    ticker := time.NewTicker(5 * time.Minute)
    go func() {
        for {
            select {
            case <-ticker.C:
                cs.removeInactiveCarts()
            }
        }
    }()
}
```

### 9.2 Concurrency Optimization

#### Lock Granularity
Current implementation uses:
- **Service-level RWMutex**: Protects the carts map
- **Cart-level RWMutex**: Protects individual cart items

**Performance Benefits**:
- Multiple users can modify their carts simultaneously
- Read operations (get cart) don't block each other
- Write operations only block conflicting operations

#### Lock-free Alternatives
For higher concurrency, consider:
- **sync.Map**: For cart storage
- **Atomic operations**: For simple counters
- **Channel-based communication**: For cart updates

### 9.3 Metrics Performance Impact

#### Overhead Analysis
OpenTelemetry metrics introduce minimal overhead:
- **Counter operations**: ~50-100ns per increment
- **Histogram operations**: ~200-500ns per record
- **Gauge callbacks**: Run every 5 seconds (configurable)

#### Optimization Techniques
1. **Batch Updates**: Aggregate metrics before recording
2. **Sampling**: Reduce histogram recording frequency for high-volume endpoints
3. **Attribute Cardinality**: Limit the number of unique attribute combinations

#### Example Optimization
```go
// Batch metrics for high-frequency operations
type MetricsBatch struct {
    requests map[string]int64
    errors   map[string]int64
    mutex    sync.Mutex
}

func (mb *MetricsBatch) flushPeriodically(ctx context.Context, service *CartService) {
    ticker := time.NewTicker(10 * time.Second)
    go func() {
        for {
            select {
            case <-ticker.C:
                mb.flush(ctx, service)
            case <-ctx.Done():
                return
            }
        }
    }()
}
```

---

## 10. Troubleshooting

### 10.1 Common Issues and Solutions

#### Issue: Metrics Not Appearing
**Symptoms**: `/metrics` endpoint returns empty or incomplete data

**Possible Causes**:
1. Meter provider not set globally
2. Metrics not being recorded in code paths
3. Exporter configuration issues

**Solutions**:
```go
// Ensure global meter provider is set
otel.SetMeterProvider(meterProvider)

// Verify metrics are being recorded
log.Printf("Recording metric: %s = %d", metricName, value)

// Check exporter configuration
exporter, err := prometheus.New(
    prometheus.WithoutCounterSuffixes(), // Optional: cleaner metric names
    prometheus.WithoutUnits(),           // Optional: remove unit suffixes
)
```

#### Issue: High Memory Usage
**Symptoms**: Application memory usage grows continuously

**Possible Causes**:
1. Cart data not being cleaned up
2. High cardinality metrics attributes
3. Memory leaks in metric collection

**Solutions**:
```go
// Implement cart cleanup
func (cs *CartService) cleanupOldCarts() {
    cutoff := time.Now().Add(-1 * time.Hour)
    cs.mutex.Lock()
    defer cs.mutex.Unlock()
    
    for userID, cart := range cs.carts {
        if cart.lastAccessed.Before(cutoff) {
            delete(cs.carts, userID)
        }
    }
}

// Limit metric attribute cardinality
func limitedAttributes(userID string) []attribute.KeyValue {
    // Group users into buckets to limit cardinality
    bucket := fmt.Sprintf("bucket_%d", hash(userID)%10)
    return []attribute.KeyValue{
        attribute.String("user_bucket", bucket),
    }
}
```

#### Issue: Slow Response Times
**Symptoms**: API endpoints responding slowly

**Possible Causes**:
1. Lock contention between operations
2. Expensive metrics operations
3. Inefficient data structures

**Solutions**:
```go
// Use read locks where possible
func (cs *CartService) GetCartSize(userID string) int {
    cs.mutex.RLock()         // Read lock instead of write lock
    cart, exists := cs.carts[userID]
    cs.mutex.RUnlock()
    
    if !exists {
        return 0
    }
    
    cart.mutex.RLock()       // Read lock for cart items
    size := len(cart.Items)
    cart.mutex.RUnlock()
    
    return size
}

// Optimize metric recording
func (cs *CartService) recordLatencyOptimized(ctx context.Context, duration time.Duration, attrs []attribute.KeyValue) {
    // Only record if duration is significant
    if duration > time.Millisecond {
        cs.requestLatency.Record(ctx, duration.Seconds(), metric.WithAttributes(attrs...))
    }
}
```

### 10.2 Debugging Techniques

#### Enable Debug Logging
```go
import (
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/metric"
)

// Enable debug logging for OpenTelemetry
func setupDebugLogging() {
    // Set log level for debugging
    otel.SetLogger(logr.New(&debugLogger{}))
}

type debugLogger struct{}

func (d *debugLogger) Info(level int, msg string, keysAndValues ...interface{}) {
    log.Printf("OTEL INFO: %s %v", msg, keysAndValues)
}

func (d *debugLogger) Error(err error, msg string, keysAndValues ...interface{}) {
    log.Printf("OTEL ERROR: %s %v: %v", msg, keysAndValues, err)
}
```

#### Metrics Validation
```go
func validateMetrics() {
    // Check if metrics are being collected
    resp, err := http.Get("http://localhost:8080/metrics")
    if err != nil {
        log.Printf("Failed to fetch metrics: %v", err)
        return
    }
    defer resp.Body.Close()
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        log.Printf("Failed to read metrics: %v", err)
        return
    }
    
    metrics := string(body)
    expectedMetrics := []string{
        "http_requests_total",
        "http_request_duration_seconds",
        "cart_items_total",
        "active_users_total",
    }
    
    for _, metric := range expectedMetrics {
        if !strings.Contains(metrics, metric) {
            log.Printf("Missing metric: %s", metric)
        }
    }
}
```

### 10.3 Production Monitoring

#### Health Check Enhancement
```go
func (ms *MetricsServer) handleHealthDetailed(w http.ResponseWriter, r *http.Request) {
    health := map[string]interface{}{
        "status":      "healthy",
        "timestamp":   time.Now().UTC().Format(time.RFC3339),
        "service":     "shopping-cart-service",
        "version":     "1.0.0",
        "uptime":      time.Since(startTime).String(),
        "active_carts": len(ms.service.carts),
    }
    
    // Check if metrics are working
    if !ms.metricsHealthy() {
        health["status"] = "degraded"
        health["warnings"] = []string{"metrics collection issues"}
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(health)
}
```

#### Alerting Rules
For production deployment, implement alerting based on:

1. **Error Rate**: `rate(http_requests_errors_total[5m]) > 0.05`
2. **High Latency**: `histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 1.0`
3. **Memory Growth**: Monitor cart_items_total for unexpected growth
4. **Service Availability**: Health endpoint returning non-200 status codes

---

## Conclusion

This comprehensive implementation demonstrates professional-grade OpenTelemetry metrics integration in a Go application. The shopping cart service showcases all three primary metric types while following industry best practices for observability, concurrency, and production readiness.

Key achievements of this implementation:
- **Complete Metric Coverage**: Counter, Histogram, and Gauge metrics with real-world use cases
- **Production-Ready Code**: Proper error handling, concurrency control, and resource management
- **Comprehensive Documentation**: Detailed explanations suitable for team knowledge transfer
- **Extensible Architecture**: Easy to add new metrics and modify existing functionality
- **Performance Optimized**: Efficient concurrent operations with minimal overhead

The service is ready for production deployment and provides a solid foundation for building observable microservices with OpenTelemetry.
